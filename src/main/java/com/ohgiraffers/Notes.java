package com.ohgiraffers;

public class Notes {

    public static void main(String[] args) {

        /* 객체지향 언어
        *   코드의 재사용성이 높고 유지보수가 용이, 중복코드 제거
        *   객체지향 언어 = 프로그래밍 언어 + 객체지향개념(규칙)
        *
        *   OOP(Object-Oriented-Programming)
        *   1. 캡슐화
        *   2. 상속
        *   3. 추상화
        *   4. 다형성
        *
        * ❗ 반복학습, 규칙 외우기
        * */

        /* 클래스와 객체
        *   클래스의 정의 : 클래스란 객체를 정의해 놓은 것
        *   클래스의 용도 : 클래스는 객체를 생성하는데 사용
        *
        *   객체의 정의 : 실제로 존재하는 것. 사물 또는 개념
        *   객체의 용도 : 객체가 가지고 있는 기능과 속성에 따라 다름
        *
        *       클래스         |         객체
        * ------------------------------------------
        *     제품 설계도       |         제품
        *     TV 설계도        |          TV
        *     붕어빵 기계       |         붕어빵
        *
        * 1. TV 설계도를 만드는 이유 : TV라는 객체를 만들기 위해
        * 2. TV는 만드는 이유 : 우리가 사용하기 위해
        * 3. TV를 만드려면 : 먼저 설계도를 만든다 -> 설계도를 이용해 TV를 만든다.
        *
        * 객체의 구성요소 - 속성과 기능
        * 객체 = 속성(변수) + 기능(메소드)
        * TV의 속성 : 크기, 길이, 높이, 색상, 볼륨, 채널 등
        * TV의 기능 : 켜기, 끄기, 볼륨 높이기, 볼륨 낮추기, 채널 변경하기 등
        *
        * 객체와 인스턴스
        * 객체 : 모든 인스턴스를 대표하는 일반적 용어
        * 인스턴스 : 특정 클래스로부터 생성된 객체(예 : Tv인스턴스)
        * 객체 ≒ 인스턴스
        *
        *             (설계도로 제품을 만드는 것)
        *                   인스턴스화
        *       클래스 ---------------------> 인스턴스(객체)
        *      (설계도)                          (제품)
        *
        *  클래스(설계도)가 왜 필요한가?
        *   - 객체(제품)를 생성하기 위해
        *  객체가 왜 필요한가?
        *   - 객체(제품)를 사용하기 위해
        *  객체를 사용한다는 것은?
        *   - 객체(TV)가 가진 속성(변수)과 기능(메소드)을 사용하려고
        *
        * 객체의 생성과 사용 ; 클래스(설계도) 작성
        *
        * 1. 객체의 생성
        * 클래스명 변수명;             // 클래스의 객체를 참조하기 위한 참조변수를 선언
        * 변수명 = new 클래스명();     // 클래스의 객체를 생성 후, 객체의 주소를 참조변수에 저장
        *
        * Tv t; ①참조변수(리모콘)      // Tv클래스 타입의 참조변수 t를 선언
        * t = new Tv();              // Tv인스턴스를 생성한 후, 생성된 Tv인스턴스의 주소를 t에 저장
        *③연결     ②객체
        * --> Tv t = new Tv();       // 새로운 Tv를 만들어서 리모콘(t)에 연결해준다.
        *
        * 2. 객체의 사용               // 객체가 가지고 있는 변수와 메소드를 사용한다.
        * t.channel = 7;             // 참조변수 t가 가리키는 객체의 변수(channel)에 7을 적용
        * t.channelDown();           // 참조변수 t가 가리키는 메소드(channelDown) 호출
        * System.out.println("현재 채널은 " + t.channel + " 입니다.)
        * */

        /* 순서
        *   1. 클래스 작성
        *   2. 객체생성
        *   3. 객체 사용
        * */

        /* 객체 배열
        * 객체 배열 = 참조변수 배열
        * Tv tv1, tv2, tv3;     -> Tv[] tvArr = new Tv[3]; // 길이가 3인 Tv타입의 참조변수 배열
        * 객체를 생성해서 배열의 각 요소에 저장
        * tvArr[0] = new Tv();
        * tvArr[1] = new Tv();
        * tvArr[2] = new Tv();
        * Tv[] tvArr = { new Tv(), new Tv(), new Tv() };
        * */

        /* 클래스의 정의(1)
         * ① 설계도
         * ② 데이터 + 함수
         * ③ 사용자 정의 타입
         *
         * 클래스 == 데이터 + 함수
         * 1. 변수 : 하나의 데이터를 저장할 수 있는 공간
         * 2. 배열 : 같은 종류(같은 타입만)의 여러 데이터를 하나로 저장할 수 있는 공간
         * 3. 구조체 : 서로 관련된 여러 데이터(종류 관계 X)를 하나로 저장할 수 있는 공간
         *          변수     ----->     배열     ----->     구조체     ----->     클래스
         *           1                  1                    1                1
         *                              2                  10.0f            10.0f   +   함수
         *                              3                   'a'              'a'
         *                         같은 타입만            서로관계있는     변수(데이터) + 메소드(명령문 묶음)
         *                                                                    서로 관련 있는
         *
         * 사용자 정의 타입 - 원하는 타입(클래스)을 직접 만들 수 있다.
         *                                        class Time {
         *                                              int hour;
         *                                              int minute;
         *                                              int second;
         *                                         }
         * int hour;                        |
         * int minute;                      | <->   Time t= new Time();
         * int second;                      |
         * ---------------------------------------------------------------
         * int hour1, hour2, hour3          | <->   Time t1= new Time();
         * int minute1, minute2, minute3    | <->   Time t2= new Time();
         * int second1, second2, second3    | <->   Time t3= new Time();
         * ---------------------------------------------------------------
         *                                  |   Time[] t = new Time[3];
         * int[] hour = new int[3]          | <->   t[0] = new Time();
         * int[] minute = new int[3]        | <->   t[1] = new Time();
         * int[] second = new int[3]        | <->   t[2] = new Time();
         * ---------------------------------------------------------------
         * ex) 12시 34분 56초                |   Time t= new Time();
         * int hour = 12;                   |   t.hour = 12;
         * int minute = 34;                 |   t.minute = 34;
         * int second = 56;                 |   t.second = 56;
         * */

        /* 선언위치에 따른 변수의 종류 (Variables 클래스 참고)
        *
        *        변수의 종류                    선언위치                         생성시기
        *   ----------------------------------------------------------------------------------------
        *        클래스변수 cv                클래스 영역                 클래스가 메모리에 올라갈 때
        *      (class variable)
        *   ----------------------------------------------------------------------------------------
        *       인스턴스변수 iv               클래스 영역                   인스턴스가 생성되었을 때
        *    (instance variable)
        *   ----------------------------------------------------------------------------------------
        *         지역변수 lv            클래스 영역 이외의 영역           변수 선언문이 수행되었을 때
        *     (local variable)     (메서드 생성자, 초기화 블럭 내부)
        * */


        /* 클래스 변수와 인스턴스 변수 */
        /* ex 포커카드가 있다.
        * 속성 : 무늬, 숫자 ... 폭, 높이 등
        * 카드는 각각 Card 객체
        * 숫자, 무늬 : 개별 - 객체마다 다르게 유지 되어야 함.
        * 폭, 높이 : 공통 : 모든 객체가 공통적으로 동일해야 함.
        *
        * 인스턴스 변수(개별 속성)
        * String kind;       // 무늬
        * int number;        // 숫자
        *
        * 클래스 변수(공통 속성)
        * static int width;     // 폭
        * static int height;    // 높이
        * */


        /* 메서드란?
        * 1. 문장들을 묶어 놓은 것.
        *   - 작업단위로 문장들을 묶어서 이름 붙인 것
        * 2. 값(입력)을 받아서 처리하고 결과를 반환(출력)
        *
        *       반환타입(출력) | 메서드 이름 | 매개변수선언(입력)
        *           int            add      (int x, int y)
        *
        *   int add(int x, int y){
        *      int result = x + y;
        *      return = result; // 결과 반환
        *   }
        *
        * 메서드의 장점
        *   1. 코드의 중복을 줄일 수 있다.
        *   2. 코드의 관리가 쉽다.
        *   3. 코드를 재사용할 수 있다.
        *   4. 코드가 간결해서 이해하기 쉬워진다.
        *
        * 메서드의 작성
        *   - 반복적으로 수행되는 여러 문장을 메서드로 작성
        *   - 하나의 메서드는 한가지 기능만 수행하도록 작성
        *
        * 메서드 = 선언부 + 구현부
        * 반환타입 메서드이름 (타입 변수명, 타입변수명, ...) - 선언부
        *                   매개변수(입력) 0 ~ n개
        * { 메서드 호출 시 수행될 코드 } - 구현부
        *                   (출력) 0 ~ 1개
        *
        * 지역변수(lv) : 메서드 내에 선언된 변수
        * int add(int x, int y) {
        *     int result = x + y;
        *     return = result;
        * }
        * int multiply(int x, int y) {
        *     int result = x * y;
        *     return = result;
        * }
        * 메서드 영역이 다르기 때문에 이름(int result)이 같아도 서로 겹치지 않는다.
        * */


        /* 메서드의 호출
        * 메서드명(값1, 값2, ...) // 메서드를 호출하는 방법
        * ex)
        * print99danAll()           // void print99danAll()을 호출
        * int result = add(3, 5);   // int add(int x, int y)를 호출하고, 결과를 result에 저장
        *
        * 메서드는 클래스 영역에만 정의 가능.
        * */

        /* 메서드의 실행 흐름
        *   --- (메인 메서드) ---
        *   MyMath myMath = new MyMath();       // 먼저 인스턴스를 생성한다.
        *   long value = mm.add(1L, 2L);        // 메서드를 호출한다.
        *   --- (MyMath 클래스) ---
        *   long add(long a, long b) {
        *       long result = a + b;
        *       return result;
        *   }
        *   ① main메서드에서 메서드 add를 호출한다. 인수 1L과 2L이 메서드 add 매개변수 a, b에 각각 복사(대입)된다.
        *   ② 메서드 add의 괄호 { } 안에 있는 문장들이 순서대로 수행된다.
        *   ③ 메서드 add의 모든 문장이 실행되거나 return문을 만나면, 호출한 메서드(main 메서드)로 되돌아와서 이후의 문장들을 실행한다.
        * */


        /* return 문
        *   - 실행 중인 메서드를 종료하고 호출한 곳으로 되돌아간다.
        *   void printGugudan(int dan) {
        *        if(!(2 <= dan && dan <= 9))
        *               return;  // dan의 값이 2 ~ 9가 아닌 경우, 호출한 곳으로 되돌아간다.
        *
        *        for(int i = 1; i <= 9; i++) {
        *               System.out.printf("%d * %d = %d%n, dan, dan * i);
        *        }
        *        return;        // 반환타입이 void 이므로 생략 가능. 컴파일러가 자동추가해준다.
        *   }
        *
        * 반환타입이 void가 아닌 경우, 반드시 return문 필요
        * 반환값은 타입이 일치해야한다. (자동형변환도 가능)
        * */


        /* ⚠ 호출 스택(call stack)
        *   스택(stack) : 밑이 막힌 상자. 위에 차곡차곡 쌓인다.
        *   메서드 수행에 필요한 메모리가 제공되는 공간
        *   메서드가 호출되면 호출스택에 메모리 할당, 종료되면 해제
        *   아래 있는 메서드가 위의 메서드를 호출한 것
        *   맨 위의 메서드 하나만 실행 중, 나머지는 대기중
        * */


        /* 기본형 매개변수
        * 기본형(8개) 매개변수 - 변수의 값을 읽기만 할 수 있다.(read only)
        * 참조형 매개변수 - 변수의 값을 읽고 변경할 수 있다.(read & write)
        * */

        /* 참조형 매개변수*/


        /* static 메서드와 인스턴스 메서드(iv 사용여부)
        *   ✅인스턴스 메서드
        *   - 인스턴스 생성 후, '참조변수.메서드이름()'으로 호출
        *   - 인스턴스 멤버(iv, im)와 관련된 작업을 하는 메서드
        *   - 메서드 내에서 인스턴스 변수(iv) 사용 가능
        *
        *   ✅static 메서드(클래스 메서드)
        *   - 객체생성없이 '클래스이름.메서드이름()'으로 호출  ex)Math.random()
        *   - 인스턴스 멤버(iv, im)와 관련없는 작업을 하는 메서드
        *   - 메서드 내에서 인스턴스 변수(iv) 사용 불가
        * */


        /* static을 언제 붙여야 할까?
        *
        * ✅속성(멤버 변수) 중에서 공통 속성에 static을 붙인다.
        *
        * class Card {
        *       String kind;                // 무늬 (개별속성) 인스턴스 변수
        *       int number;                 // 숫자 (개별속성) 인스턴스 변수
        *
        *       static int width = 100;     // 폭    (공통속성) 클래스 변수
        *       static int height = 250;    // 높이   (공통속성) 클래스 변수
        *
        * ✅ 인스턴스멤버(iv, im)을 사용하지 않는 메서드에 static을 붙인다.
        * class MyMath2 {
        *   long a, b;
        *
        *   long add() {
        *       return a + b;           // a, b는 인스턴스 변수
        *   }
        *
        *   static add(long a, long b) {
        *       return a + b;           // a, b는 지역 변수
        *   }
        * */

        /* 메서드 간의 호출과 참조
        * Q. static 메서드는 static 메서드 호출 가능?
        * A. 네
        * Q. static 메서드는 인스턴스 변수 사용 가능?
        * A. 아니오
        * Q. static 메서드는 인스턴스 메서드 호출 가능?
        * A. 아니오
        * Q. 왜 static 메서드는 인스턴스 멤버를 쓸 수 없나요?
        * A. static 메서드 호출 시 객체(iv 묶음)가 없을 수도 있어서
        * */


        /* 오버로딩(overloading)
        *   한 클래스 안에 같은 이름의 메서드 여러개를 정의하는 것
        *
        * ✅ 오버로딩이 성립하기 위한 조건
        *   1. 메서드 이름이 같아야 한다.
        *   2. 매개변수의 개수 또는 타입이 달라야 한다.
        *   3. 반환 타입은 영향 없다.
        *   ---------------------------------------------
        *       int add(int a, int b) { return a + b; }     // 변수 이름만 다르기 때문에 오버로딩 X
        *       int add(int x, int y) { return x + y; }     // 메서드 중복정의(에러)
        *   ---------------------------------------------
        *       int add(int a, int b) { return a + b; }             // 매개변수가 동일하고 반환타입은 영향이 없기 때문에 오버로딩 X
        *       long add(int a, int b) { return (long)(a + b); }    // 메서드 중복정의(에러)
        *   ---------------------------------------------
        *       long add(int a, long b) { return a + b; }   // 오버로딩 성립
        *       long add(long a, int b) { return a + b; }   // 매개변수 타입이 다름
        *       호출시 입력 값이 모호할 경우  ex) add(3, 3) 둘 중 무엇을 선택할지 모르기에 에러 발생
        * */


        /* 생성자(constructor) = iv 초기화 메서드
        *   - 인스턴스가 생성될 때마다 호출되는 '인스턴스 초기화 메서드'
        * Time t = new Time();  // ① 객체 생성
        * t.hour = 12;
        * t.minute = 34;        // ② iv 초기화
        * t.second = 56;
        * 위의 고정이 번거로우니 아래 방법으로 간단히 표현 가능
        * Time t = new Time(12, 34, 56);
        *  - (12, 34, 56) 부분이 생성자 호출
        *  - 생성자를 추가해야 함.
        *
        * - 이름이 클래스 이름과 같아야 한다.
        *   클래스이름(타입 변수명, 타입 변수명, ... ) {
        *       // 인스턴스 생성 시 수행될 코드,
        *       // 주로 인스턴스 변수의 초기화 코드를 적는다.
        *  }
        *
        * class Card {
        *       ...
        *       Card() { // 매개변수 없는 생성자. (기본 생성자)
        *           // 인스턴스 초기화 작업
        *       }
        *
        *       Card(String kind, int number) { // 매개변수 있는 생성자
        *           // 인스턴스 초기화 작업
        *       }
        * }
        *
        * - 리턴값이 없다.(void 안붙임)
        * - 모든 클래스는 반드시 생성자를 가져야 한다. (1개 이상)
        *   ex) Card c = new Card(); <-- (기본)생성자 호출
        * */


        /* 기본생성자(default constructor)
        *   - 매개변수가 없는 생성자
        *   - 생성자가 하나도 없을 때만, 컴파일러가 자동 추가
        *
        *   클래스이름() { }             // 기본생성자
        *   Point() { }                // Point클래스의 기본 생성자(왠만하면 직접 작성하자)
        *
        * */

        /* 매개변수가 있는 생성자
        *   class Car {
        *       String color;       // 색상
        *       String gearType;    // 변속기 종류 - auto(자동), manual(수동)
        *       int door;           // 문의 개수
        *
        *   Car() { }               // 기본 생성자
        *   Car(String c, String g, int d) { // 매개변수가 있는 생성자
        *       color = c;
        *       gearType = g;
        *       door = d;
        *   }
        *
        *   Car c = new Car();
        *   c.color = "white";
        *   c.gearType = "auto";    ---> Car c = new Car("white", "auto", 4);
        *   c. door = 4;
        *
        * */


        /* 생성자 this()
        *   - 생성자에서 다른 생성자 호출할 때 사용
        *       *class Car2 참조
        *   - 다른 생성자 호출 시 첫 줄에서만 사용 가능
        *       Car(String color) {
        *           door = 5; // 첫번째 줄이 아니라 에러가 난다
        *           Car(color, "auto, 4); // Car가 아닌 this를 사용
        *
        *   class Car {
        *       String color;
        *       String gearType;
        *       int door;
        *                                                          * 코드의 중복을 제거한 코드
        *       Car() {    아무것도 지정하지 않으면                        Car() {
        *           color = "white";    디폴트값 지정                         // Car("white", "auto", 4);
        *           gearType = "auto";                                      this("white", "audo", 4);
        *           door = 4;                                           }
        *       }
        *
        *       Car(String c, String g, int d) {
        *           color = c;
        *           gearType = g;                       // 코드의 중복을 제거하기 위해 기본생성자에서 아래 생성자를 호출함.
        *           door = d;
        *       }
        * */

        /* 참조변수 this                     != this() 생성자  <-- 둘은 다른 것.
        *   - 인스턴스 자신을 가리키는 참조변수
        *   - 인스턴스 메서드(생성자 포함)에서 사용가능
        *   - 지역변수(lv)와 인스턴스 변수(iv)를 구별할 때 사용
        *   -------------------------------------------------------------------------------------------------------
        *   Car(String c, String g, int d) {        --->        Car(String color, String gearType, int door) {
        *       // color는 iv, c는 lv                --->           // this.color는 iv, color는 lv
        *       color = c;                          --->            this.color = color;
        *       gearType = g;                       --->            this.gearType = gearType;
        *       door = d;                           --->            this.door = door;
        *   }                                       --->        }
        *       같은 클래스 내에서 this 생략 가능       --->            iv와 lv 이름이 같을 경우 구별을 하기 위해 this. 붙임
        *   -------------------------------------------------------------------------------------------------------
        * */

        /* 참조변수 this와 생성자 this()
        *   this : 인스턴스 자신을 가리키는 참조변수. 인스턴스의 주소가 저장되어 있다.
        *          모든 인스턴스 메서드에 지역변수로 숨겨진 채로 존재한다.
        *   this(), this(매개변수) 생성자, 같은 클래스의 다른 생성자를 호출할 때 사용한다.
        * */


        /* 변수의 초기화
        *   - 지역변수(lv)는 수동 초기화 해야함(사용전 꼭!!!)
        *   - 멤버변수(iv, cv)는 자동 초기화 된다.
        *
        *   class InitTest {
        *       int x;                          // 인스턴스 변수
        *       int y = x;                      // 인스턴스 변수
        *
        *       void method1() {
        *           int i;                      // 지역 변수
        *           int j = i;                  // 에러. 지역변수 i를 초기화하지 않고 사용.
        *       }
        *   }
        * */

        /* 멤버변수(iv, cv)의 초기화
        *   1. 명시적 초기화 (=)  <-- 대입연산자(선언시) / 간단초기화
        *       class Car {
        *           int door = 4;                       // 기본형(primitive type) 변수의 초기화
        *           Engine e = new Engine();            // 참조형(reference type) 변수의 초기화
        *       }
        *                                                * 참조형변수 - null(기본값)
        *                                                           - 객체 주소(참조형 변수는 객체를 생성해서 넣어주어야 한다)
        *
        *   2. 초기화 블럭   (복잡한 초기화)
        *   - 인스턴스 초기화 블럭 : { 여러문장 넣기 }
        *   - 클래스 초기화 블럭 : static { }
        *
        *   3. 생성자        (iv 초기화, 복잡한 초기화)
        *     Car(String color, String gearType, int door) { // 매개변수 있는 생성자
        *           this.color = color;
        *           this.gearType = gearType;
        *           this.door = door;
        *     }
        *
        *   ① 자동 초기화  : 0
        *   ② 간단 초기화  : '=' 사용
        *   ③ 복잡한 초기화 : {} , static { }, 생성자
        *                           cv         iv
        *
        *   class StaticBlockTest {
        *        static int[] arr = new int[10]; // 명시적 초기화
        *                    (cv)      (배열 생성)
        *        static {  // 클래스 초기화 블럭 - 배열 arr을 난수로 채운다.
        *           for(int i = 0; i < arr.length; i++) {                   // cv 복잡 초기화
        *               arr[i] = (int)(Math.random() * 10) + 1;
        *        }
        * */

        /* 멤버변수의 초기화
        *   ✅ 클래스 변수 초기화 시점 : 클래스가 처음 로딩(메모리에 올라갈 때)될 때 단 한번
        *   ✅ 인스턴스 변수(iv) 초기화 시점 : 인스턴스가 생성될 때 마다
        *       class InitTest {
        *           static int cv = 1;          // 명시적 초기화
        *           int iv = 1;                 // 명시적 초기화
        *
        *           static { cv = 2; }          // 클래스 초기화 블럭
        *           { iv = 2; }                 // 인스턴스 초기화 블럭
        *
        *           InitTest() {                // 생성자
        *               iv = 3;
        *           }
        *
        * */



    }

}
